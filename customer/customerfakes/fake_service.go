// Code generated by counterfeiter. DO NOT EDIT.
package customerfakes

import (
	"sync"

	"github.com/TStuchel/go-service/customer"
)

type FakeService struct {
	CreateCustomerStub        func(customer.Customer) (*customer.Customer, error)
	createCustomerMutex       sync.RWMutex
	createCustomerArgsForCall []struct {
		arg1 customer.Customer
	}
	createCustomerReturns struct {
		result1 *customer.Customer
		result2 error
	}
	createCustomerReturnsOnCall map[int]struct {
		result1 *customer.Customer
		result2 error
	}
	GetCustomerStub        func(string) (*customer.Customer, error)
	getCustomerMutex       sync.RWMutex
	getCustomerArgsForCall []struct {
		arg1 string
	}
	getCustomerReturns struct {
		result1 *customer.Customer
		result2 error
	}
	getCustomerReturnsOnCall map[int]struct {
		result1 *customer.Customer
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeService) CreateCustomer(arg1 customer.Customer) (*customer.Customer, error) {
	fake.createCustomerMutex.Lock()
	ret, specificReturn := fake.createCustomerReturnsOnCall[len(fake.createCustomerArgsForCall)]
	fake.createCustomerArgsForCall = append(fake.createCustomerArgsForCall, struct {
		arg1 customer.Customer
	}{arg1})
	fake.recordInvocation("CreateCustomer", []interface{}{arg1})
	fake.createCustomerMutex.Unlock()
	if fake.CreateCustomerStub != nil {
		return fake.CreateCustomerStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createCustomerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) CreateCustomerCallCount() int {
	fake.createCustomerMutex.RLock()
	defer fake.createCustomerMutex.RUnlock()
	return len(fake.createCustomerArgsForCall)
}

func (fake *FakeService) CreateCustomerCalls(stub func(customer.Customer) (*customer.Customer, error)) {
	fake.createCustomerMutex.Lock()
	defer fake.createCustomerMutex.Unlock()
	fake.CreateCustomerStub = stub
}

func (fake *FakeService) CreateCustomerArgsForCall(i int) customer.Customer {
	fake.createCustomerMutex.RLock()
	defer fake.createCustomerMutex.RUnlock()
	argsForCall := fake.createCustomerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeService) CreateCustomerReturns(result1 *customer.Customer, result2 error) {
	fake.createCustomerMutex.Lock()
	defer fake.createCustomerMutex.Unlock()
	fake.CreateCustomerStub = nil
	fake.createCustomerReturns = struct {
		result1 *customer.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeService) CreateCustomerReturnsOnCall(i int, result1 *customer.Customer, result2 error) {
	fake.createCustomerMutex.Lock()
	defer fake.createCustomerMutex.Unlock()
	fake.CreateCustomerStub = nil
	if fake.createCustomerReturnsOnCall == nil {
		fake.createCustomerReturnsOnCall = make(map[int]struct {
			result1 *customer.Customer
			result2 error
		})
	}
	fake.createCustomerReturnsOnCall[i] = struct {
		result1 *customer.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetCustomer(arg1 string) (*customer.Customer, error) {
	fake.getCustomerMutex.Lock()
	ret, specificReturn := fake.getCustomerReturnsOnCall[len(fake.getCustomerArgsForCall)]
	fake.getCustomerArgsForCall = append(fake.getCustomerArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetCustomer", []interface{}{arg1})
	fake.getCustomerMutex.Unlock()
	if fake.GetCustomerStub != nil {
		return fake.GetCustomerStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getCustomerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeService) GetCustomerCallCount() int {
	fake.getCustomerMutex.RLock()
	defer fake.getCustomerMutex.RUnlock()
	return len(fake.getCustomerArgsForCall)
}

func (fake *FakeService) GetCustomerCalls(stub func(string) (*customer.Customer, error)) {
	fake.getCustomerMutex.Lock()
	defer fake.getCustomerMutex.Unlock()
	fake.GetCustomerStub = stub
}

func (fake *FakeService) GetCustomerArgsForCall(i int) string {
	fake.getCustomerMutex.RLock()
	defer fake.getCustomerMutex.RUnlock()
	argsForCall := fake.getCustomerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeService) GetCustomerReturns(result1 *customer.Customer, result2 error) {
	fake.getCustomerMutex.Lock()
	defer fake.getCustomerMutex.Unlock()
	fake.GetCustomerStub = nil
	fake.getCustomerReturns = struct {
		result1 *customer.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeService) GetCustomerReturnsOnCall(i int, result1 *customer.Customer, result2 error) {
	fake.getCustomerMutex.Lock()
	defer fake.getCustomerMutex.Unlock()
	fake.GetCustomerStub = nil
	if fake.getCustomerReturnsOnCall == nil {
		fake.getCustomerReturnsOnCall = make(map[int]struct {
			result1 *customer.Customer
			result2 error
		})
	}
	fake.getCustomerReturnsOnCall[i] = struct {
		result1 *customer.Customer
		result2 error
	}{result1, result2}
}

func (fake *FakeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCustomerMutex.RLock()
	defer fake.createCustomerMutex.RUnlock()
	fake.getCustomerMutex.RLock()
	defer fake.getCustomerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ customer.Service = new(FakeService)
